/*
    mosta go-back-n.modest -X -S -E -O out.dot -D png out.png --no-invariants -F
    modes go-back-n.modest -E "N=5"
    
    TODO: 
        a)      - proper timeout
                - take care of sending window N
                - why are there timeout and drop actions? with whom do they sync?
        b-d)    - insert properties
    
*/


patient action rdt_snd, udt_snd_s, udt_snd_s_done, udt_snd_r, udt_snd_r_done, rdt_rcv_s, rdt_rcv_r, deliver_data, deliver_data_done;
patient action timeout, drop_data;

datatype packet = {
	int seqnum,
	int data // unused in ACKs
};

// Packet lists
datatype packetlist = { packet hd, packetlist option tl };
function int length(packetlist option ls) = // returns the length of packet list <ls>
	if ls == null then 0 else 1 + length(ls!.tl);
function packet at(packetlist option ls, int index) = // returns the packet at index <index> in packet list <ls>
	if index == 0 then ls!.hd else at(ls!.tl, index - 1);
function packetlist append(packetlist option ls, packet item) = // inserts packet <item> at the end of packet list <ls>
	if ls == none then packetlist { hd: item, tl: none } else packetlist { hd: ls!.hd, tl: append(ls!.tl, item) };
function packetlist option remove(packetlist option ls, int count) = // removes the first <count> packets from packet list <ls>
	if ls == none then none else if count == 0 then ls else remove(ls!.tl, count - 1);

// real lists (used internally by the channels)
datatype reallist = { real hd, reallist option tl };
function reallist appendR(reallist option ls, real item) =
	if ls == none then reallist { hd: item, tl: none } else reallist { hd: ls!.hd, tl: appendR(ls!.tl, item) };

// Model parameters
const int N; // window size
const int PKT_COUNT = 128; // number of app-layer messages to send
const int PKT_LOSS_PROB = 10; // probability (in %) to lose a packet
const int ACK_LOSS_PROB = 10; // probability (in %) to lose an acknowledgment
const int PKT_TRANS_DELAY = 2; // transmission delay of a packet (do not change)
const int PKT_PROP_DELAY = 10; // average propagation delay of a packet (do not change)
const int ACK_TRANS_DELAY = 1; // transmission delay of an acknowledgment (do not change)
const int ACK_PROP_DELAY = 10; // average propagation delay of an acknowledgment (do not change)

// Basic error checking: ProbError should be 0 and DeliveredPackets should be PKT_COUNT
bool hasError;
bool lastDelivered;
int deliveredPacketCount;
property ProbError = Pmax(<> (hasError || lastDelivered && deliveredPacketCount != PKT_COUNT));
property DeliveredPackets = Xmax(deliveredPacketCount | lastDelivered);

// Properties
// TODO: Insert your properties here

// Upper layers on sender side
// Do not modify this process
process UpperLayerSender()
{
	int i;
	clock c;

	do {
		when urgent(i < PKT_COUNT) rdt_snd {= usdata = (i + 23635) % 16384, i++ =}
	}
}

// RDT implementation on sender side
const int TIMEOUT = 30; // sender timeout
int usdata; // data buffer from upper layer to sender
packet cspacket; // data buffer from channel to sender
process Sender()
{
    int send_base = 1;
    int next_seqnum = 1;
    int retransmit_index = 0;
    int retransmit_length = 0;
    clock c;
    
    bool timer_on = false;

    packetlist pl = packetlist { };
    packet next_pkt;
    
    // TODO !!!!!!!!!!!!!!!!!!!!
    
    do {
        ::  urgent rdt_snd         // receive call from upper layer
            {=
                next_pkt = packet { seqnum: next_seqnum, data: usdata },
                pl = append(pl, next_pkt),
                scpacket = next_pkt
            =};
            alt {
                :: when urgent (send_base == next_seqnum) urgent {= c = 0, timer_on = true =}
                :: when urgent (send_base > next_seqnum) tau
            };
            {= next_seqnum = next_seqnum + 1  =};
            urgent udt_snd_s; 
            urgent udt_snd_s_done
        :: urgent rdt_rcv_s   // receive data from lower layer
            {= pl = remove(pl, cspacket.seqnum - send_base) =};
            alt {
                :: when urgent (length(pl) == 0) {=  timer_on = false, pl = packetlist{ } =}
                :: when urgent (length(pl) > 0) tau
            };
            urgent {= send_base = cspacket.seqnum =}
        /*:: when urgent (c >= TIMEOUT && timer_on)
            {=
                retransmit_index = 0,
                retransmit_length = length(pl)
            =};
            do {
                :: when urgent (retransmit_index < retransmit_length) {= scpacket = at(pl, retransmit_index) =};
                    urgent udt_snd_s; 
                    urgent udt_snd_s_done
                :: when urgent (retransmit_index == retransmit_length) break
            }*/
            
    }
}

// UDT service from sender to receiver: has a send buffer of 16 packets and loses PKT_LOSS_PROB out of 100 packets
// Do not modify this process
packet scpacket; // data buffer from sender to channel
process ChannelSR()
{
	packetlist option packets;
	reallist option packetTimes;
	var timer; der(timer) = 1;
	real sendUntil;
	
	par {
	::	do
		{	// Get packets
			urgent udt_snd_s;
			urgent alt {
			::	when(length(packets) <= 16) udt_snd_s_done palt {
				:100-PKT_LOSS_PROB:
					{=	sendUntil = max(sendUntil + PKT_TRANS_DELAY, timer + PKT_TRANS_DELAY),
						packets = append(packets, scpacket),
						packetTimes = appendR(packetTimes, max(sendUntil + PKT_TRANS_DELAY, timer + PKT_TRANS_DELAY) + Exp(1/PKT_PROP_DELAY)) =}
				:PKT_LOSS_PROB:
					{= sendUntil = max(sendUntil + PKT_TRANS_DELAY, timer + PKT_TRANS_DELAY) =}
				}
			::	when(length(packets) > 16) udt_snd_s_done // queue overflow, drop packet
			}
		}
	::	do
		{	// Deliver packets
			when urgent(packets != none && timer >= packetTimes!.hd) rdt_rcv_r {= crpacket = packets!.hd, packets = packets!.tl, packetTimes = packetTimes!.tl =}
		}
	}
}

// UDT service from receiver to sender: has a send buffer of 16 packets and loses ACK_LOSS_PROB out of 100 packets
// Do not modify this process
packet rcpacket; // data buffer from receiver to channel
process ChannelRS()
{
	packetlist option packets;
	reallist option packetTimes;
	var timer; der(timer) = 1;
	real sendUntil;
	
	par {
	::	do
		{	// Get packets
			urgent udt_snd_r;
			urgent alt {
			::	when(length(packets) <= 16) urgent udt_snd_r_done palt {
				:100-PKT_LOSS_PROB:
					{=	sendUntil = max(sendUntil + ACK_TRANS_DELAY, timer + ACK_TRANS_DELAY),
						packets = append(packets, rcpacket),
						packetTimes = appendR(packetTimes, max(sendUntil + ACK_TRANS_DELAY, timer + ACK_TRANS_DELAY) + Exp(1/ACK_PROP_DELAY)) =}
				:PKT_LOSS_PROB:
					{= sendUntil = max(sendUntil + ACK_TRANS_DELAY, timer + ACK_TRANS_DELAY) =}
				}
			::	when(length(packets) > 16) udt_snd_r_done // queue overflow, drop packet
			}
		}
	::	do
		{	// Deliver packets
			when urgent(packets != none && timer >= packetTimes!.hd) rdt_rcv_s {= cspacket = packets!.hd, packets = packets!.tl, packetTimes = packetTimes!.tl =}
		}
	}
}

// RDT implementation on receiver side
packet crpacket; // data buffer from channel to receiver
process Receiver()
{
    int received_seqnum = 0;
    
    // TODO !!!!!!!!!!!!!!!!!!!!
    do {
        ::  urgent rdt_rcv_r;      // get the data from the channel
            alt {
            ::  when urgent (crpacket.seqnum == received_seqnum + 1)  // expected sequence number
                    urgent deliver_data {= rudata = crpacket.data, received_seqnum = crpacket.seqnum =}; 
                    urgent deliver_data_done
            ::  when urgent (crpacket.seqnum > received_seqnum + 1)  // unexpected number
                    // DROP THE PACKET
                    {= rcpacket = packet { seqnum: received_seqnum } =}
            };
            urgent {= rcpacket = packet { seqnum: received_seqnum } =};
            urgent udt_snd_r;
            urgent udt_snd_r_done
    }
}

// Upper layers on receiver side: count packets and make sure there is no duplicate data
// Do not modify this process.
int rudata; // data buffer from receiver to upper layer
process UpperLayerReceiver()
{
	int nextData = 23635 % 16384;
	do {
		urgent deliver_data;
		urgent deliver_data_done {= deliveredPacketCount++, lastDelivered = rudata == (23634 + PKT_COUNT) % 16384, hasError = hasError || rudata != nextData, nextData = rudata == nextData ? (nextData + 1) % 16384 : nextData =}
	}
}

par {
::	UpperLayerSender()
::	Sender()
::	ChannelSR()
::	ChannelRS()
::	Receiver()
::	UpperLayerReceiver()
}