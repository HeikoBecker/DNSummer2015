/*
    mosta go-back-n.modest -X -S -E -O out.dot -D png out.png --no-invariants
    modes go-back-n.modest -E "N=5" -R Uniform
    
    TODO: 
        a)      - proper timeout
        b-d)    - insert properties
    
*/

patient action rdt_snd, udt_snd_s, udt_snd_s_done, udt_snd_r, udt_snd_r_done, rdt_rcv_s, rdt_rcv_r, deliver_data, deliver_data_done;
patient action timeout, drop_data;

datatype packet = {
	int seqnum,
	int data // unused in ACKs
};

// Packet lists
datatype packetlist = { packet hd, packetlist option tl };
function int length(packetlist option ls) = // returns the length of packet list <ls>
	if ls == null then 0 else 1 + length(ls!.tl);
function packet at(packetlist option ls, int index) = // returns the packet at index <index> in packet list <ls>
	if index == 0 then ls!.hd else at(ls!.tl, index - 1);
function packetlist append(packetlist option ls, packet item) = // inserts packet <item> at the end of packet list <ls>
	if ls == none then packetlist { hd: item, tl: none } else packetlist { hd: ls!.hd, tl: append(ls!.tl, item) };
function packetlist option remove(packetlist option ls, int count) = // removes the first <count> packets from packet list <ls>
	if ls == none then none else if count == 0 then ls else remove(ls!.tl, count - 1);

// real lists (used internally by the channels)
datatype reallist = { real hd, reallist option tl };
function reallist appendR(reallist option ls, real item) =
	if ls == none then reallist { hd: item, tl: none } else reallist { hd: ls!.hd, tl: appendR(ls!.tl, item) };

// Model parameters
const int N; // window size
const int PKT_COUNT = 128; // number of app-layer messages to send
const int PKT_LOSS_PROB = 10; // probability (in %) to lose a packet
const int ACK_LOSS_PROB = 10; // probability (in %) to lose an acknowledgment
const int PKT_TRANS_DELAY = 2; // transmission delay of a packet (do not change)
const int PKT_PROP_DELAY = 10; // average propagation delay of a packet (do not change)
const int ACK_TRANS_DELAY = 1; // transmission delay of an acknowledgment (do not change)
const int ACK_PROP_DELAY = 10; // average propagation delay of an acknowledgment (do not change)

// Basic error checking: ProbError should be 0 and DeliveredPackets should be PKT_COUNT
bool hasError;
bool lastDelivered;
int deliveredPacketCount;
property ProbError = Pmax(<> (hasError || lastDelivered && deliveredPacketCount != PKT_COUNT));
property DeliveredPackets = Xmax(deliveredPacketCount | lastDelivered);

// Properties

// Upper layers on sender side
// Do not modify this process
process UpperLayerSender()
{
	int i;
	clock c;

	do {
		when urgent(i < PKT_COUNT) rdt_snd {= usdata = (i + 23635) % 16384, i++ =}
	}
}

// RDT implementation on sender side
const int TIMEOUT = 30; // sender timeout
int usdata; // data buffer from upper layer to sender
packet cspacket; // data buffer from channel to sender
process Sender()
{
    packetlist option packets;
    int send_base = 1;
    int next_seqnum = 1;
    int retr_idx = 0;
    bool timer_on = false;
    clock retr_timer;
    
    do {
        // receive call from upper layer
        ::  when urgent (next_seqnum - send_base < N) rdt_snd;         
            urgent udt_snd_s
            {=
                scpacket = packet { seqnum: next_seqnum, data: usdata },
                packets = append(packets, scpacket),
                timer_on = true,
                next_seqnum++
            =};
            urgent udt_snd_s_done
        // receive data from lower layer
        :: urgent rdt_rcv_s;
            urgent tau {=
                packets = remove(packets, (cspacket.seqnum + 1) - send_base), 
                send_base = cspacket.seqnum + 1,
                timer_on = (next_seqnum - (cspacket.seqnum + 1) > 0),
                retr_timer = 0
            =}
        :: when urgent (timer_on && (retr_timer >= TIMEOUT)) timeout;
            do {
                :: when urgent (retr_idx < length(packets))
                    urgent udt_snd_s
                    {= 
                        scpacket = at(packets, retr_idx),
                        retr_idx++
                    =}; 
                    urgent udt_snd_s_done
                :: when urgent (retr_idx >= length(packets))
                    break {= retr_timer = 0, retr_idx = 0 =}
            }
    }
}

// UDT service from sender to receiver: has a send buffer of 16 packets and loses PKT_LOSS_PROB out of 100 packets
// Do not modify this process
packet scpacket; // data buffer from sender to channel
process ChannelSR()
{
	packetlist option packets;
	reallist option packetTimes;
	var timer; der(timer) = 1;
	real sendUntil;
	
	par {
	::	do
		{	// Get packets
			urgent udt_snd_s;
			urgent alt {
			::	when(length(packets) <= 16) udt_snd_s_done palt {
				:100-PKT_LOSS_PROB:
					{=	sendUntil = max(sendUntil + PKT_TRANS_DELAY, timer + PKT_TRANS_DELAY),
						packets = append(packets, scpacket),
						packetTimes = appendR(packetTimes, max(sendUntil + PKT_TRANS_DELAY, timer + PKT_TRANS_DELAY) + Exp(1/PKT_PROP_DELAY)) =}
				:PKT_LOSS_PROB:
					{= sendUntil = max(sendUntil + PKT_TRANS_DELAY, timer + PKT_TRANS_DELAY) =}
				}
			::	when(length(packets) > 16) udt_snd_s_done // queue overflow, drop packet
			}
		}
	::	do
		{	// Deliver packets
			when urgent(packets != none && timer >= packetTimes!.hd) rdt_rcv_r {= crpacket = packets!.hd, packets = packets!.tl, packetTimes = packetTimes!.tl =}
		}
	}
}

// UDT service from receiver to sender: has a send buffer of 16 packets and loses ACK_LOSS_PROB out of 100 packets
// Do not modify this process
packet rcpacket; // data buffer from receiver to channel
process ChannelRS()
{
	packetlist option packets;
	reallist option packetTimes;
	var timer; der(timer) = 1;
	real sendUntil;
	
	par {
	::	do
		{	// Get packets
			urgent udt_snd_r;
			urgent alt {
			::	when(length(packets) <= 16) urgent udt_snd_r_done palt {
				:100-PKT_LOSS_PROB:
					{=	sendUntil = max(sendUntil + ACK_TRANS_DELAY, timer + ACK_TRANS_DELAY),
						packets = append(packets, rcpacket),
						packetTimes = appendR(packetTimes, max(sendUntil + ACK_TRANS_DELAY, timer + ACK_TRANS_DELAY) + Exp(1/ACK_PROP_DELAY)) =}
				:PKT_LOSS_PROB:
					{= sendUntil = max(sendUntil + ACK_TRANS_DELAY, timer + ACK_TRANS_DELAY) =}
				}
			::	when(length(packets) > 16) udt_snd_r_done // queue overflow, drop packet
			}
		}
	::	do
		{	// Deliver packets
			when urgent(packets != none && timer >= packetTimes!.hd) rdt_rcv_s {= cspacket = packets!.hd, packets = packets!.tl, packetTimes = packetTimes!.tl =}
		}
	}
}

// RDT implementation on receiver side
packet crpacket; // data buffer from channel to receiver
process Receiver()
{
    int recv_seqnum = 0;
    do {
        urgent rdt_rcv_r;       // get the data from the channel
        alt {
            // expected sequence number or previous number
            :: when urgent (crpacket.seqnum == recv_seqnum + 1)
                    urgent deliver_data {= 
                        rudata = crpacket.data, 
                        recv_seqnum = crpacket.seqnum
                    =};
                    urgent deliver_data_done
            // unexpected number
            :: when urgent (crpacket.seqnum != recv_seqnum + 1) urgent drop_data
        };
        urgent udt_snd_r {= rcpacket = packet { seqnum: recv_seqnum } =};
        urgent udt_snd_r_done
    }
}

// Upper layers on receiver side: count packets and make sure there is no duplicate data
// Do not modify this process.
int rudata; // data buffer from receiver to upper layer
process UpperLayerReceiver()
{
	int nextData = 23635 % 16384;
	do {
		urgent deliver_data;
		urgent deliver_data_done {= deliveredPacketCount++, lastDelivered = rudata == (23634 + PKT_COUNT) % 16384, hasError = hasError || rudata != nextData, nextData = rudata == nextData ? (nextData + 1) % 16384 : nextData =}
	}
}

par {
::	UpperLayerSender()
::	Sender()
::	ChannelSR()
::	ChannelRS()
::	Receiver()
::	UpperLayerReceiver()
}